/*******************************************************************************
*
*  McStas, neutron ray-tracing package
*  Copyright(C) 2000 Risoe National Laboratory.
*
* %I
* Written by: Mads Bertelsen, using Phonon_simple by Kim Lefmann
* Date: 04.02.04
* Version: $Revision: 1.0 $
* Origin: Graevlingestien 31C
*
* A sample for simultaneous inelastic and elastic scattering at two (plane) Q positions.
*
* %D
* Single-cylinder shape.
* Absorption included.
* No multiple scattering.
* No attenuation from coherent scattering.
*
* Algorithm:
* 0. Scattering with probability p_interact, otherwise transmit with absorption correction
* 1. Choose direction within a focusing solid angle
* 2. Choose a random energy transfer, apply weight reduction to get desired distribution
* 3. Calculate q
* 4. Apply weight transformation as a function of q
* 5. Correct for absorption on the full path
*
* %P
* INPUT PARAMETERS:
* radius:  [m] Outer radius of sample in (x,z) plane
* yheight: [m] Height of sample in y direction
* mu_abs_th:[m^-1] Attenuation coeficient for absorption at 2200 m/s (cross_section*N/V)
* mu_elastic:[m^-1] Attentuation coeficient for elastic scattering (cross_section*N/V)
* mu_inelastic:[m^-1] Attentuation coeficient for inelastic scattering (cross_section*N/V)
* p_interact: [1] Probability for interacting with the sample (elastic or inelastic scattering)
* p_elastic: [1] Forced probability for events in elastic channel, the rest in inelastic.
* q_x_elastic: [AA^-1] peak center for elastic peak x
* q_z_elastic: [AA^-1] peak center for elastic peak z
* q_x_inelastic: [AA^-1] peak center for inelastic peak x
* q_z_inelastic: [AA^-1] peak center for inelastic peak z
* width_E_elastic: [meV] energy width of elastic peak
* inelastic_min_DE: [meV] smallest energy change of the neutron (can be negative)
* inelastic_max_DE: [meV] largest energy change for the neutron
* focus_r: [m] Radius of sphere containing target.
* focus_xw:[m] horiz. dimension of a rectangular area
* focus_yh:[m] vert.  dimension of a rectangular area [m]
* focus_aw:[m] horiz. angular dimension of a rectangular area [deg]
* focus_ah:[m] vert.  angular dimension of a rectangular area [deg]
* target_x:[m] position of target to focus at . Transverse coordinate
* target_y:[m] position of target to focus at [m]. Vertical coordinate
* target_z:[m] position of target to focus at [m]. Straight ahead.
* target_index: relative index of component to focus at, e.g. next is +1 [1]
*
* OUTPUT PARAMETERS:
* V_rho:  [AA^-3] Atomic density
* V_mu_s: [m^-1]  Attenuation factor due to incoherent scattering
* V_mu_a: [m^-1]  Attenuation factor due to absorbtion
*
* %L
* The test/example instrument <a href="../examples/Test_Phonon.instr">Test_Phonon.instr</a>.
*
* %E
******************************************************************************/

DEFINE COMPONENT double_peak_flag2
DEFINITION PARAMETERS ()
SETTING PARAMETERS (radius,
                    yheight,
                    mu_abs_th,
                    q_x_elastic,
                    q_z_elastic,
                    q_x_inelastic,
                    q_z_inelastic,
                    q_width_elastic,
                    q_width_inelastic,
                    elastic_E_width,
                    inelastic_min_DE,
                    inelastic_max_DE,
                    mu_elastic,
                    mu_inelastic,
                    p_interact,
                    elastic_probability,
                    target_x=0,
                    target_y=0,
                    target_z=0,
                    int target_index=0,
                    focus_r=0,
                    focus_xw=0,
                    focus_yh=0,
                    focus_aw=0,
                    focus_ah=0)
OUTPUT PARAMETERS (V_rho, V_mu_s, V_mu_a, DV,mu_total)
/* Neutron parameters: (x,y,z,vx,vy,vz,t,sx,sy,sz,p) */ 
SHARE
%{
#ifndef PHONON_SIMPLE
#define PHONON_SIMPLE $Revision: 1.7 $
#endif
%}

DECLARE
%{
//  double V_rho;
//  double V_mu_s;
//  double V_mu_a_v;
//  double DV;
  double mu_abs_v;
  double mu_total;
  int elastic_flag;
  
//    int count_smaller,count_larger;
%}
INITIALIZE
%{
//  V_rho = 4/(a*a*a);
//  V_mu_s = (V_rho * 100 * sigma_inc);
//  V_mu_a_v = (V_rho * 100 * sigma_abs * 2200);
  mu_abs_v = mu_abs_th*2200;
  mu_total = mu_inelastic + mu_elastic;
  
  /* now compute target coords if a component index is supplied */
  if (!target_index && !target_x && !target_y && !target_z) target_index=1;
  if (target_index){
    Coords ToTarget;
    ToTarget = coords_sub(POS_A_COMP_INDEX(INDEX_CURRENT_COMP+target_index),POS_A_CURRENT_COMP);
    ToTarget = rot_apply(ROT_A_CURRENT_COMP, ToTarget);
    coords_get(ToTarget, &target_x, &target_y, &target_z);
  }
  if (!(target_x || target_y || target_z)) {
    printf("double_peak: %s: The target is not defined. Using direct beam (Z-axis).\n",
      NAME_CURRENT_COMP);
    target_z=1;
    
    // count_smaller = 0;
    // count_larger = 0;
  }
%}
TRACE
%{
  double t0, t1;                /* Entry/exit time for cylinder */
  double v_i, v_f;               /* Neutron velocities: initial, final */
  double vx_i, vy_i, vz_i;  /* Neutron initial velocity vector */
  double dt0, dt;             /* Flight times through sample */
  double l_full;                /* Flight path length for non-scattered neutron */
  double l_i, l_o;              /* Flight path lenght in/out for scattered neutron */
  double mu_a_i;                  /* Initial attenuation factor */
  double mu_a_f;                  /* Final attenuation factor */
  double solid_angle;              /* Solid angle of target as seen from scattering point */
  double aim_x=0, aim_y=0, aim_z=1;   /* Position of target relative to scattering point */
  double f1, f2;            /* probed values of omega_q minus omega */
  double p1,p2,p3,p4,p5;    /* temporary multipliers */
  double E_i, E_f,delta_E;  /* Initial energy, final energy and delta energy */
  double comp_q_peak_x,comp_q_peak_z; /* Position of q peak */
  double comp_q_peak_width;      /* width of q_peak */
  double k_xi,k_yi,k_zi;    /* initial wavevector */
  double k_xf,k_yf,k_zf;    /* final wavevector */
  double qx,qy,qz;          /* scattering vector */
  double Q_dist;            /* Temporary variable */
  double p_trans,p_scatt,mc_scatt,mc_trans;
  double elastic_part,real_elastic_probability;

  int verbose;
  
  elastic_flag = -1;

  if(cylinder_intersect(&t0, &t1, x, y, z, vx, vy, vz, radius, yheight))
  {
    if(t0 < 0)
      ABSORB; /* Neutron came from the sample or begins inside */
    
    verbose = 0;
    /* Neutron enters at t=t0. */
    dt0 = t1-t0;                /* Time in sample */
    v_i = sqrt(vx*vx + vy*vy + vz*vz);
    mu_a_i = mu_abs_v/v_i;
    l_full = v_i * dt0;   /* Length of path through sample if not scattered */
    
    // mu_total = total my for inelastic and elastic scattering
    // p_interact implementation
    p_trans = exp(-mu_total*l_full);
    p_scatt = 1 - p_trans;

    if (verbose == 1) printf("new neutron -------------------------\n");
    
    if (p_interact>0 && p_interact<=1) {
        /* we force a portion of the beam to interact */
        /* This is used to improve statistics on single scattering */
        mc_trans = 1-p_interact;
    } else {
        mc_trans = p_trans;
    }
    mc_scatt = 1 - mc_trans; /* portion of beam to scatter (or force to) */
    
    if (verbose == 1) printf("p_interact = %lf\n",p_interact);
    if (verbose == 1) printf("mc_trans = %lf\n",mc_trans);
    if (!(mc_scatt >= 1 || (rand01()) < mc_scatt)) {
        // Transmission
        p *= fabs(p_trans/mc_trans);
        PROP_DT(t1);
        p *= exp(-(mu_a_i*l_full)); // Transmission takes absorption into account
        if (verbose == 1) printf("Transmission\n");
    } else {
        // Scattering
        if (verbose == 1) printf("Scattering\n");
        p *= fabs(p_scatt/mc_scatt);
    
        dt = rand01()*dt0;    /* Time of scattering (relative to t0) */
        l_i = v_i*dt;                 /* Penetration in sample at scattering */
        vx_i=vx;
        vy_i=vy;
        vz_i=vz;
        PROP_DT(dt+t0);             /* Point of scattering */

        aim_x = target_x-x;         /* Vector pointing at target (e.g. analyzer) */
        aim_y = target_y-y;
        aim_z = target_z-z;

        if(focus_aw && focus_ah) {
            randvec_target_rect_angular(&vx, &vy, &vz, &solid_angle,aim_x, aim_y, aim_z, focus_aw, focus_ah, ROT_A_CURRENT_COMP);
        } else if(focus_xw && focus_yh) {
            randvec_target_rect(&vx, &vy, &vz, &solid_angle,aim_x, aim_y, aim_z, focus_xw, focus_yh, ROT_A_CURRENT_COMP);
        } else {
                randvec_target_sphere(&vx,&vy,&vz,&solid_angle,aim_x,aim_y,aim_z, focus_r);
        }
        NORM(vx, vy, vz);
            /*    printf("focussed direction (vx,vy,vz=(%g %g %g) \n",vx,vy,vz); */

        // Select if it should be elastic or inelastic
    
        E_i = VS2E*v_i*v_i;
        if (verbose == 1) printf("E_i = %lf\n",E_i);
        
        elastic_part = (1-exp(-mu_elastic*l_full));
        real_elastic_probability = elastic_part/(elastic_part+(1-exp(-mu_inelastic*l_full)));
        
        if (rand01() < elastic_probability) {
            // delta_E = elastic_E_width*randnorm(); risk of being less than 0
            delta_E = elastic_E_width*10.1*(rand01()-0.5);
            while (delta_E < -E_i) {
              delta_E = elastic_E_width*5*(rand01()-0.5);
              // printf("lol, disaster adverted\n");
              }
            p *= exp(-delta_E*delta_E/(2*elastic_E_width*elastic_E_width))/elastic_E_width/sqrt(2*3.14159);
            p *= l_full*mu_elastic; // Monte carlo probability correction for chossing scattering point from a flat distrobution
            comp_q_peak_x = q_x_elastic;
            comp_q_peak_z = q_z_elastic;
            comp_q_peak_width = q_width_elastic;
            
            elastic_flag = 1;
            
            // correction for chosing elastic with probability elastic_probability instead of real_elastic_probability
            p *= real_elastic_probability/elastic_probability;
        } else {
            // delta_E = inelastic_E_width*randnorm();
            delta_E = (inelastic_max_DE-inelastic_min_DE)*rand01()+inelastic_min_DE;
            while (delta_E < -E_i) {
                delta_E = (inelastic_max_DE-inelastic_min_DE)*rand01()+inelastic_min_DE;
             // printf("lol, disaster adverted\n");
             }
            // uncomment for gauss energy distribution around 0 DE
            //p *= exp(-delta_E*delta_E/(2*inelastic_E_width*inelastic_E_width))/inelastic_E_width/sqrt(2*3.14159);
            
            elastic_flag = 0;
            
            p *= fabs(inelastic_max_DE-inelastic_min_DE); // Corrects for sampleing probability in area min_DE to max_DE.
            p *= l_full*mu_inelastic; // Monte carlo probability correction for chossing scattering point from a flat distrobution
            comp_q_peak_x = q_x_inelastic;
            comp_q_peak_z = q_z_inelastic;
            comp_q_peak_width = q_width_inelastic;
            // correction for chosing inelastic with probability (1-elastic_probability) instead of (1-real_elastic_probability)
            p *= (1-real_elastic_probability)/(1-elastic_probability);
        }
        if (verbose == 1) printf("Delta_E = %lf\n",delta_E);
        // if (delta_E < 0) ++count_smaller; else ++count_larger;
        // if (verbose == 1) printf("count_smaller = %d, count_larger = %d\n",count_smaller,count_larger);
        

        
        // Change the energy, use normalized v_f to obtain v_f
        E_f = E_i + delta_E;
        
        if (verbose == 1) printf("E_f = %lf\n",E_f);
        v_f = SE2V*sqrt(E_f);
        mu_a_f = mu_abs_v/v_f;
        if (verbose == 1) printf("E_f (actual1) = %lf\n",v_f*v_f*VS2E);
        vx *= v_f;
        vy *= v_f;
        vz *= v_f;
        if (verbose == 1) printf("E_f (actual2) = %lf\n",sqrt(vx*vx+vy*vy+vz*vz)*sqrt(vx*vx+vy*vy+vz*vz)*VS2E);
    
        // At this point we have v_i and v_f, calculate Q
        k_xi = V2K*vx_i; k_yi = V2K*vy_i; k_zi = V2K*vz_i;
        k_xf = V2K*vx; k_yf = V2K*vy; k_zf = V2K*vz;
        qx = k_xi - k_xf;
        qy = k_yi - k_yf;
        qz = k_zi - k_zf;
        if (verbose == 1) printf("q = (%lf, %lf, %lf)\n",qx,qy,qz);
        
        // Apply weight reduction
        Q_dist = sqrt((comp_q_peak_x - qx)*(comp_q_peak_x - qx)+(comp_q_peak_z - qz)*(comp_q_peak_z - qz)); // dist from Q_peak to Q
        
        if (exp(-Q_dist*Q_dist/(2*comp_q_peak_width*comp_q_peak_width))/comp_q_peak_width/sqrt(2*3.14159)>0){
        p *= exp(-Q_dist*Q_dist/(2*comp_q_peak_width*comp_q_peak_width))/comp_q_peak_width/sqrt(2*3.14159);
        
   } else {
    ABSORB;
    }
    

        if(!cylinder_intersect(&t0, &t1, x, y, z, vx, vy, vz, radius, yheight)) {
            /* ??? did not hit cylinder */
            printf("--------------------- FATAL ERROR -------------------------\n");
            printf("Ray did not hit cylinder from inside.\n");
            printf("Most likely because ray was accidently given zero velocity.\n");
            printf("v_i = (%lf, %lf, %lf)\n",vx_i,vy_i,vz_i);
            printf("v_f = (%lf, %lf, %lf)\n",vx,vy,vz);
            printf("If above velocities looks reasonable, it can also be\n");
            printf(" because gravity is enabled and a very unlikely event.\n");
            printf("Terminating run.\n");
            printf("-----------------------------------------------------------\n");
            exit(1);
        }
        dt = t1;
        l_o = v_f*dt;

        //p *= exp(-(V_mu_s*(l_i+l_o)+mu_a_i*l_i+mu_a_f*l_o)); // Absorption factor
        p *= exp(-(mu_a_i*l_i+mu_a_f*l_o)-(l_o+l_i)*mu_total); // Absorption factor
        p *= solid_angle/(4*PI);     // Focusing factors
        p *= (v_f/v_i);
        
    // Lack a factor correcting the probability for the neutron actually scattering in the sample, and adjusting for the position it did
    

    /*
    // bose_factor=nbose(omega,T);
    p1 = exp(-(V_mu_s*(l_i+l_o)+mu_a_i*l_i+mu_a_f*l_o)); // Absorption factor
    p2 = nf*solid_angle*l_full*V_rho/(4*PI);     // Focusing factors; assume random choice of n_f possibilities
    p3 = (v_f/v_i)*DW*(kappa2*K2V*K2V*VS2E)/fabs(omega)*bose_factor;   // Cross section factor 1
    p4 = 2*VS2E*v_f/J_factor;  // Jacobian of delta functions in cross section
    p5 = b*b/M;  // Cross section factor 2
    p *= p1*p2*p3*p4*p5;
    */

/*    printf("p factors : %g %g %g %g %g Omega: %g \n", p1, p2, p3, p4, p5, omega);
      printf("J_factor %g l_full %g, v_f/v_i %g, DW %g, kappa2 %g, bose_factor%g, fabs(omega) %g \n",
              J_factor, l_full, v_f/v_i, DW, kappa2, bose_factor, fabs(omega)); */
    }
  } /* else transmit: Neutron did not hit the sample */
%}

MCDISPLAY
%{
  magnify("xyz");
  circle("xz", 0,  yheight/2.0, 0, radius);
  circle("xz", 0, -yheight/2.0, 0, radius);
  line(-radius, -yheight/2.0, 0, -radius, +yheight/2.0, 0);
  line(+radius, -yheight/2.0, 0, +radius, +yheight/2.0, 0);
  line(0, -yheight/2.0, -radius, 0, +yheight/2.0, -radius);
  line(0, -yheight/2.0, +radius, 0, +yheight/2.0, +radius);
%}

END

